<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/common/aop/ResultAspect.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/common/aop/ResultAspect.java" />
              <option name="originalContent" value="package io.github.talelin.latticy.common.aop;&#10;&#10;import cn.hutool.core.util.StrUtil;&#10;import io.github.talelin.latticy.common.configuration.CodeMessageConfiguration;&#10;import io.github.talelin.latticy.vo.UnifyResponseVO;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.aspectj.lang.annotation.AfterReturning;&#10;import org.aspectj.lang.annotation.Aspect;&#10;import org.aspectj.lang.annotation.Pointcut;&#10;import org.springframework.stereotype.Component;&#10;&#10;/**&#10; * 处理返回结果为 UnifyResponseVO 的视图函数&#10; * 默认的返回均是英文，在此处通过code替换成中文&#10; *&#10; * @author pedro@TaleLin&#10; * @author colorful@TaleLin&#10; */&#10;@Aspect&#10;@Component&#10;@Slf4j&#10;public class ResultAspect {&#10;&#10;&#10;    @Pointcut(&quot;execution(public * io.github.talelin.latticy.controller..*.*(..))&quot;)&#10;    public void handlePlaceholder() {&#10;    }&#10;&#10;    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;handlePlaceholder()&quot;)&#10;    public void doAfterReturning(Object ret) throws Throwable {&#10;        if (ret instanceof UnifyResponseVO) {&#10;            UnifyResponseVO result = (UnifyResponseVO) ret;&#10;            int code = result.getCode();&#10;            String message = CodeMessageConfiguration.getMessage(code);&#10;            if (StrUtil.isNotBlank(message) &amp;&amp; StrUtil.isBlank((CharSequence) result.getMessage())) {&#10;                result.setMessage(message);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package io.github.talelin.latticy.common.aop;&#10;&#10;import cn.hutool.core.util.StrUtil;&#10;import io.github.talelin.latticy.common.configuration.CodeMessageConfiguration;&#10;import io.github.talelin.latticy.vo.UnifyResponseVO;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.aspectj.lang.annotation.AfterReturning;&#10;import org.aspectj.lang.annotation.Aspect;&#10;import org.aspectj.lang.annotation.Pointcut;&#10;import org.springframework.stereotype.Component;&#10;&#10;/**&#10; * 处理返回结果为 UnifyResponseVO 的视图函数&#10; * 默认的返回均是英文，在此处通过code替换成中文&#10; *&#10; * @author pedro@TaleLin&#10; * @author colorful@TaleLin&#10; */&#10;@Aspect&#10;@Component&#10;@Slf4j&#10;public class ResultAspect {&#10;&#10;&#10;    @Pointcut(&quot;execution(public * io.github.talelin.latticy.controller..*.*(..))&quot;)&#10;    public void handlePlaceholder() {&#10;    }&#10;&#10;    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;handlePlaceholder()&quot;)&#10;    public void doAfterReturning(Object ret) throws Throwable {&#10;        if (ret instanceof UnifyResponseVO) {&#10;            UnifyResponseVO result = (UnifyResponseVO) ret;&#10;            int code = result.getCode();&#10;            String message = CodeMessageConfiguration.getMessage(code);&#10;            // 检查是否需要设置消息，避免类型转换异常&#10;            if (StrUtil.isNotBlank(message)) {&#10;                Object currentMessage = result.getMessage();&#10;                // 只有当前消息为null、空字符串或者是字符串类型且为空时才设置新消息&#10;                if (currentMessage == null ||&#10;                    (currentMessage instanceof String &amp;&amp; StrUtil.isBlank((String) currentMessage))) {&#10;                    result.setMessage(message);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/common/interceptor/AuthorizeVerifyResolverImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/common/interceptor/AuthorizeVerifyResolverImpl.java" />
              <option name="originalContent" value="package io.github.talelin.latticy.common.interceptor;&#10;&#10;import com.auth0.jwt.exceptions.AlgorithmMismatchException;&#10;import com.auth0.jwt.exceptions.InvalidClaimException;&#10;import com.auth0.jwt.exceptions.JWTDecodeException;&#10;import com.auth0.jwt.exceptions.SignatureVerificationException;&#10;import com.auth0.jwt.exceptions.TokenExpiredException;&#10;import com.auth0.jwt.interfaces.Claim;&#10;import io.github.talelin.autoconfigure.bean.MetaInfo;&#10;import io.github.talelin.autoconfigure.exception.AuthenticationException;&#10;import io.github.talelin.autoconfigure.exception.AuthorizationException;&#10;import io.github.talelin.autoconfigure.exception.NotFoundException;&#10;import io.github.talelin.autoconfigure.exception.TokenInvalidException;&#10;import io.github.talelin.autoconfigure.interfaces.AuthorizeVerifyResolver;&#10;import io.github.talelin.core.token.DoubleJWT;&#10;import io.github.talelin.latticy.common.LocalUser;&#10;import io.github.talelin.latticy.model.PermissionDO;&#10;import io.github.talelin.latticy.model.UserDO;&#10;import io.github.talelin.latticy.service.GroupService;&#10;import io.github.talelin.latticy.service.UserService;&#10;import org.apache.logging.log4j.util.Strings;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.servlet.http.HttpServletRequest;&#10;import javax.servlet.http.HttpServletResponse;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.regex.Pattern;&#10;&#10;/**&#10; * @author pedro@TaleLin&#10; * @author Juzi@TaleLin&#10; */&#10;@Component&#10;public class AuthorizeVerifyResolverImpl implements AuthorizeVerifyResolver {&#10;&#10;    public final static String AUTHORIZATION_HEADER = &quot;Authorization&quot;;&#10;&#10;    public final static String BEARER_PATTERN = &quot;^Bearer$&quot;;&#10;&#10;    @Autowired&#10;    private DoubleJWT jwt;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    @Autowired&#10;    private GroupService groupService;&#10;&#10;    @Value(&quot;${lin.file.domain}&quot;)&#10;    private String domain;&#10;&#10;    @Value(&quot;${lin.file.serve-path:assets/**}&quot;)&#10;    private String servePath;&#10;&#10;&#10;    @Override&#10;    public boolean handleLogin(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        String tokenStr = verifyHeader(request, response);&#10;        Map&lt;String, Claim&gt; claims;&#10;        try {&#10;            claims = jwt.decodeAccessToken(tokenStr);&#10;        } catch (TokenExpiredException e) {&#10;            throw new io.github.talelin.autoconfigure.exception.TokenExpiredException(e.getMessage(), 10051);&#10;        } catch (AlgorithmMismatchException | SignatureVerificationException | JWTDecodeException | InvalidClaimException e) {&#10;            throw new TokenInvalidException(e.getMessage(), 10041);&#10;        }&#10;        return getClaim(claims);&#10;    }&#10;&#10;    @Override&#10;    public boolean handleGroup(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        handleLogin(request, response, meta);&#10;        UserDO user = LocalUser.getLocalUser();&#10;        if (verifyAdmin(user)) {&#10;            return true;&#10;        }&#10;        Integer userId = user.getId();&#10;        String permission = meta.getPermission();&#10;        String module = meta.getModule();&#10;        List&lt;PermissionDO&gt; permissions = userService.getUserPermissions(userId);&#10;        boolean matched = permissions.stream().anyMatch(it -&gt; it.getModule().equals(module) &amp;&amp; it.getName().equals(permission));&#10;        if (!matched) {&#10;            throw new AuthenticationException(&quot;you don't have the permission to access&quot;, 10001);&#10;        }&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean handleAdmin(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        handleLogin(request, response, meta);&#10;        UserDO user = LocalUser.getLocalUser();&#10;        if (!verifyAdmin(user)) {&#10;            throw new AuthenticationException(&quot;you don't have the permission to access&quot;, 10001);&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean handleRefresh(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        String tokenStr = verifyHeader(request, response);&#10;        Map&lt;String, Claim&gt; claims;&#10;        try {&#10;            claims = jwt.decodeRefreshToken(tokenStr);&#10;        } catch (TokenExpiredException e) {&#10;            throw new io.github.talelin.autoconfigure.exception.TokenExpiredException(e.getMessage(), 10051);&#10;        } catch (AlgorithmMismatchException | SignatureVerificationException | JWTDecodeException | InvalidClaimException e) {&#10;            throw new TokenInvalidException(e.getMessage(), 10041);&#10;        }&#10;        return getClaim(claims);&#10;    }&#10;&#10;    @Override&#10;    public boolean handleNotHandlerMethod(HttpServletRequest request, HttpServletResponse response, Object handler) {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public void handleAfterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {&#10;        // 记住：很重要，请求结束后，一定要清理 ThreadLocal 中的用户信息&#10;        LocalUser.clearLocalUser();&#10;    }&#10;&#10;    private boolean getClaim(Map&lt;String, Claim&gt; claims) {&#10;        if (claims == null) {&#10;            throw new TokenInvalidException(&quot;token is invalid, can't be decode&quot;, 10041);&#10;        }&#10;        int identity = claims.get(&quot;identity&quot;).asInt();&#10;        UserDO user = userService.getById(identity);&#10;        if (user == null) {&#10;            throw new NotFoundException(&quot;user is not found&quot;, 10021);&#10;        }&#10;        String avatarUrl;&#10;        if (user.getAvatar() == null) {&#10;            avatarUrl = null;&#10;        } else if (user.getAvatar().startsWith(&quot;http&quot;)) {&#10;            avatarUrl = user.getAvatar();&#10;        } else {&#10;            avatarUrl = domain + servePath.split(&quot;/&quot;)[0] + &quot;/&quot; + user.getAvatar();&#10;        }&#10;        user.setAvatar(avatarUrl);&#10;        LocalUser.setLocalUser(user);&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * 检查用户是否为管理员&#10;     *&#10;     * @param user 用户&#10;     */&#10;    private boolean verifyAdmin(UserDO user) {&#10;        return groupService.checkIsRootByUserId(user.getId());&#10;    }&#10;&#10;    private String verifyHeader(HttpServletRequest request, HttpServletResponse response) {&#10;        // 处理头部header,带有access_token的可以访问&#10;        String authorization = request.getHeader(AUTHORIZATION_HEADER);&#10;        if (authorization == null || Strings.isBlank(authorization)) {&#10;            throw new AuthorizationException(&quot;authorization field is required&quot;, 10012);&#10;        }&#10;        String[] splits = authorization.split(&quot; &quot;);&#10;        if (splits.length != 2) {&#10;            throw new AuthorizationException(&quot;authorization field is invalid&quot;, 10013);&#10;        }&#10;        // Bearer 字段&#10;        String scheme = splits[0];&#10;        // token 字段&#10;        String tokenStr = splits[1];&#10;        if (!Pattern.matches(BEARER_PATTERN, scheme)) {&#10;            throw new AuthorizationException(&quot;authorization field is invalid&quot;, 10013);&#10;        }&#10;        return tokenStr;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package io.github.talelin.latticy.common.interceptor;&#10;&#10;import com.auth0.jwt.exceptions.AlgorithmMismatchException;&#10;import com.auth0.jwt.exceptions.InvalidClaimException;&#10;import com.auth0.jwt.exceptions.JWTDecodeException;&#10;import com.auth0.jwt.exceptions.SignatureVerificationException;&#10;import com.auth0.jwt.exceptions.TokenExpiredException;&#10;import com.auth0.jwt.interfaces.Claim;&#10;import io.github.talelin.autoconfigure.bean.MetaInfo;&#10;import io.github.talelin.autoconfigure.exception.AuthenticationException;&#10;import io.github.talelin.autoconfigure.exception.AuthorizationException;&#10;import io.github.talelin.autoconfigure.exception.NotFoundException;&#10;import io.github.talelin.autoconfigure.exception.TokenInvalidException;&#10;import io.github.talelin.autoconfigure.interfaces.AuthorizeVerifyResolver;&#10;import io.github.talelin.core.token.DoubleJWT;&#10;import io.github.talelin.latticy.common.LocalUser;&#10;import io.github.talelin.latticy.model.PermissionDO;&#10;import io.github.talelin.latticy.model.UserDO;&#10;import io.github.talelin.latticy.model.UserIdentityDO;&#10;import io.github.talelin.latticy.service.GroupService;&#10;import io.github.talelin.latticy.service.UserService;&#10;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;&#10;import org.apache.logging.log4j.util.Strings;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Component;&#10;&#10;import javax.servlet.http.HttpServletRequest;&#10;import javax.servlet.http.HttpServletResponse;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.regex.Pattern;&#10;&#10;/**&#10; * @author pedro@TaleLin&#10; * @author Juzi@TaleLin&#10; */&#10;@Component&#10;public class AuthorizeVerifyResolverImpl implements AuthorizeVerifyResolver {&#10;&#10;    public final static String AUTHORIZATION_HEADER = &quot;Authorization&quot;;&#10;&#10;    public final static String BEARER_PATTERN = &quot;^Bearer$&quot;;&#10;&#10;    @Autowired&#10;    private DoubleJWT jwt;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    @Autowired&#10;    private GroupService groupService;&#10;&#10;    @Autowired&#10;    private io.github.talelin.latticy.service.UserIdentityService userIdentityService;&#10;&#10;    @Value(&quot;${lin.file.domain}&quot;)&#10;    private String domain;&#10;&#10;    @Value(&quot;${lin.file.serve-path:assets/**}&quot;)&#10;    private String servePath;&#10;&#10;&#10;    @Override&#10;    public boolean handleLogin(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        String tokenStr = verifyHeader(request, response);&#10;        Map&lt;String, Claim&gt; claims;&#10;        try {&#10;            claims = jwt.decodeAccessToken(tokenStr);&#10;        } catch (TokenExpiredException e) {&#10;            throw new io.github.talelin.autoconfigure.exception.TokenExpiredException(e.getMessage(), 10051);&#10;        } catch (AlgorithmMismatchException | SignatureVerificationException | JWTDecodeException | InvalidClaimException e) {&#10;            throw new TokenInvalidException(e.getMessage(), 10041);&#10;        }&#10;        return getClaim(claims);&#10;    }&#10;&#10;    @Override&#10;    public boolean handleGroup(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        handleLogin(request, response, meta);&#10;        UserDO user = LocalUser.getLocalUser();&#10;        if (verifyAdmin(user)) {&#10;            return true;&#10;        }&#10;        Integer userId = user.getId();&#10;        String permission = meta.getPermission();&#10;        String module = meta.getModule();&#10;        List&lt;PermissionDO&gt; permissions = userService.getUserPermissions(userId);&#10;        boolean matched = permissions.stream().anyMatch(it -&gt; it.getModule().equals(module) &amp;&amp; it.getName().equals(permission));&#10;        if (!matched) {&#10;            throw new AuthenticationException(&quot;you don't have the permission to access&quot;, 10001);&#10;        }&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean handleAdmin(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        handleLogin(request, response, meta);&#10;        UserDO user = LocalUser.getLocalUser();&#10;        if (!verifyAdmin(user)) {&#10;            throw new AuthenticationException(&quot;you don't have the permission to access&quot;, 10001);&#10;        }&#10;        return true;&#10;    }&#10;&#10;&#10;    @Override&#10;    public boolean handleRefresh(HttpServletRequest request, HttpServletResponse response, MetaInfo meta) {&#10;        String tokenStr = verifyHeader(request, response);&#10;        Map&lt;String, Claim&gt; claims;&#10;        try {&#10;            claims = jwt.decodeRefreshToken(tokenStr);&#10;        } catch (TokenExpiredException e) {&#10;            throw new io.github.talelin.autoconfigure.exception.TokenExpiredException(e.getMessage(), 10051);&#10;        } catch (AlgorithmMismatchException | SignatureVerificationException | JWTDecodeException | InvalidClaimException e) {&#10;            throw new TokenInvalidException(e.getMessage(), 10041);&#10;        }&#10;        return getClaim(claims);&#10;    }&#10;&#10;    @Override&#10;    public boolean handleNotHandlerMethod(HttpServletRequest request, HttpServletResponse response, Object handler) {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public void handleAfterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {&#10;        // 记住：很重要，请求结束后，一定要清理 ThreadLocal 中的用户信息&#10;        LocalUser.clearLocalUser();&#10;    }&#10;&#10;    private boolean getClaim(Map&lt;String, Claim&gt; claims) {&#10;        if (claims == null) {&#10;            throw new TokenInvalidException(&quot;token is invalid, can't be decode&quot;, 10041);&#10;        }&#10;        int identity = claims.get(&quot;identity&quot;).asInt();&#10;        UserDO user = userService.getById(identity);&#10;        if (user == null) {&#10;            throw new NotFoundException(&quot;user is not found&quot;, 10021);&#10;        }&#10;        &#10;        // 加载用户的身份信息&#10;        QueryWrapper&lt;UserIdentityDO&gt; identityWrapper = new QueryWrapper&lt;&gt;();&#10;        identityWrapper.lambda().eq(UserIdentityDO::getUserId, user.getId());&#10;        user.setIdentities(userIdentityService.list(identityWrapper));&#10;        &#10;        String avatarUrl;&#10;        if (user.getAvatar() == null) {&#10;            avatarUrl = null;&#10;        } else if (user.getAvatar().startsWith(&quot;http&quot;)) {&#10;            avatarUrl = user.getAvatar();&#10;        } else {&#10;            avatarUrl = domain + servePath.split(&quot;/&quot;)[0] + &quot;/&quot; + user.getAvatar();&#10;        }&#10;        user.setAvatar(avatarUrl);&#10;        LocalUser.setLocalUser(user);&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * 检查用户是否为管理员&#10;     *&#10;     * @param user 用户&#10;     */&#10;    private boolean verifyAdmin(UserDO user) {&#10;        return groupService.checkIsRootByUserId(user.getId());&#10;    }&#10;&#10;    private String verifyHeader(HttpServletRequest request, HttpServletResponse response) {&#10;        // 处理头部header,带有access_token的可以访问&#10;        String authorization = request.getHeader(AUTHORIZATION_HEADER);&#10;        if (authorization == null || Strings.isBlank(authorization)) {&#10;            throw new AuthorizationException(&quot;authorization field is required&quot;, 10012);&#10;        }&#10;        String[] splits = authorization.split(&quot; &quot;);&#10;        if (splits.length != 2) {&#10;            throw new AuthorizationException(&quot;authorization field is invalid&quot;, 10013);&#10;        }&#10;        // Bearer 字段&#10;        String scheme = splits[0];&#10;        // token 字段&#10;        String tokenStr = splits[1];&#10;        if (!Pattern.matches(BEARER_PATTERN, scheme)) {&#10;            throw new AuthorizationException(&quot;authorization field is invalid&quot;, 10013);&#10;        }&#10;        return tokenStr;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/config/RequestLoggingFilterConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/config/RequestLoggingFilterConfig.java" />
              <option name="updatedContent" value="package io.github.talelin.latticy.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.filter.CommonsRequestLoggingFilter;&#10;&#10;@Configuration&#10;public class RequestLoggingFilterConfig {&#10;&#10;    @Bean&#10;    public CommonsRequestLoggingFilter requestLoggingFilter() {&#10;        CommonsRequestLoggingFilter loggingFilter = new CommonsRequestLoggingFilter();&#10;        loggingFilter.setIncludeClientInfo(true);&#10;        loggingFilter.setIncludeQueryString(true);&#10;        loggingFilter.setIncludePayload(true);&#10;        loggingFilter.setIncludeHeaders(false);&#10;        loggingFilter.setMaxPayloadLength(10000);&#10;        loggingFilter.setAfterMessagePrefix(&quot;REQUEST DATA : &quot;);&#10;        return loggingFilter;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/config/RequestWrapperConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/config/RequestWrapperConfig.java" />
              <option name="updatedContent" value="package io.github.talelin.latticy.config;&#10;&#10;import org.springframework.boot.web.servlet.FilterRegistrationBean;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.core.Ordered;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;import org.springframework.web.util.ContentCachingRequestWrapper;&#10;&#10;import javax.servlet.FilterChain;&#10;import javax.servlet.ServletException;&#10;import javax.servlet.http.HttpServletRequest;&#10;import javax.servlet.http.HttpServletResponse;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Wraps the HttpServletRequest in a ContentCachingRequestWrapper to allow multiple reads of the request body.&#10; */&#10;@Configuration&#10;public class RequestWrapperConfig {&#10;&#10;    @Bean&#10;    public FilterRegistrationBean&lt;OncePerRequestFilter&gt; requestWrapperFilter() {&#10;        FilterRegistrationBean&lt;OncePerRequestFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;();&#10;        registrationBean.setFilter(new OncePerRequestFilter() {&#10;            @Override&#10;            protected void doFilterInternal(HttpServletRequest request,&#10;                                            HttpServletResponse response,&#10;                                            FilterChain filterChain) throws ServletException, IOException {&#10;                ContentCachingRequestWrapper wrappedRequest = new ContentCachingRequestWrapper(request);&#10;                filterChain.doFilter(wrappedRequest, response);&#10;            }&#10;        });&#10;        registrationBean.setOrder(Ordered.HIGHEST_PRECEDENCE);&#10;        return registrationBean;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/controller/v1/AuthController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/controller/v1/AuthController.java" />
              <option name="originalContent" value="package io.github.talelin.latticy.controller.v1;&#10;&#10;import com.alipay.api.AlipayApiException;&#10;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;&#10;import io.github.talelin.core.token.DoubleJWT;&#10;import io.github.talelin.core.token.Tokens;&#10;import io.github.talelin.latticy.common.constant.IdentityConstant;&#10;import io.github.talelin.latticy.dto.auth.AlipayLoginDTO;&#10;import io.github.talelin.latticy.model.UserDO;&#10;import io.github.talelin.latticy.model.UserIdentityDO;&#10;import io.github.talelin.latticy.service.AlipayService;&#10;import io.github.talelin.latticy.service.UserIdentityService;&#10;import io.github.talelin.latticy.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.validation.annotation.Validated;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/v1/mini/auth&quot;)&#10;@Validated&#10;public class AuthController {&#10;&#10;    @Autowired&#10;    private AlipayService alipayService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    @Autowired&#10;    private UserIdentityService userIdentityService;&#10;&#10;    @Autowired&#10;    private DoubleJWT jwt;&#10;&#10;    @PostMapping(&quot;/alipay&quot;)&#10;    public Map&lt;String, Object&gt; alipayLogin(@RequestBody AlipayLoginDTO dto) throws AlipayApiException {&#10;        String alipayUserId = alipayService.getUserId(dto.getAuthCode());&#10;        QueryWrapper&lt;UserIdentityDO&gt; wrapper = new QueryWrapper&lt;&gt;();&#10;        wrapper.lambda()&#10;                .eq(UserIdentityDO::getIdentityType, IdentityConstant.ALIPAY_IDENTITY)&#10;                .eq(UserIdentityDO::getIdentifier, alipayUserId);&#10;        UserIdentityDO identity = userIdentityService.getOne(wrapper);&#10;        UserDO user;&#10;        if (identity == null) {&#10;            user = UserDO.builder()&#10;                    .username(&quot;alipay_&quot; + alipayUserId)&#10;                    .nickname(dto.getNickname())&#10;                    .avatar(dto.getAvatar())&#10;                    .build();&#10;            userService.save(user);&#10;            userIdentityService.createIdentity(user.getId(), IdentityConstant.ALIPAY_IDENTITY, alipayUserId, &quot;&quot;);&#10;        } else {&#10;            user = userService.getById(identity.getUserId());&#10;            user.setNickname(dto.getNickname());&#10;            user.setAvatar(dto.getAvatar());&#10;            userService.updateById(user);&#10;        }&#10;        Tokens tokens = jwt.generateTokens(user.getId());&#10;        Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();&#10;        data.put(&quot;token&quot;, tokens.getAccessToken());&#10;        data.put(&quot;refreshToken&quot;, tokens.getRefreshToken());&#10;        Map&lt;String, Object&gt; res = new HashMap&lt;&gt;();&#10;        res.put(&quot;code&quot;, 0);&#10;        res.put(&quot;message&quot;, &quot;ok&quot;);&#10;        res.put(&quot;data&quot;, data);&#10;        return res;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package io.github.talelin.latticy.controller.v1;&#10;&#10;import com.alipay.api.AlipayApiException;&#10;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;&#10;import io.github.talelin.core.token.DoubleJWT;&#10;import io.github.talelin.core.token.Tokens;&#10;import io.github.talelin.latticy.common.constant.IdentityConstant;&#10;import io.github.talelin.latticy.dto.auth.AlipayLoginDTO;&#10;import io.github.talelin.latticy.model.UserDO;&#10;import io.github.talelin.latticy.model.UserIdentityDO;&#10;import io.github.talelin.latticy.service.AlipayService;&#10;import io.github.talelin.latticy.service.UserIdentityService;&#10;import io.github.talelin.latticy.service.UserService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.validation.annotation.Validated;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/v1/mini/auth&quot;)&#10;@Validated&#10;public class AuthController {&#10;&#10;    @Autowired&#10;    private AlipayService alipayService;&#10;&#10;    @Autowired&#10;    private UserService userService;&#10;&#10;    @Autowired&#10;    private UserIdentityService userIdentityService;&#10;&#10;    @Autowired&#10;    private DoubleJWT jwt;&#10;&#10;    @PostMapping(&quot;/alipay&quot;)&#10;    public Map&lt;String, Object&gt; alipayLogin(@RequestBody AlipayLoginDTO dto) throws AlipayApiException {&#10;        String alipayUserId = alipayService.getUserId(dto.getAuthCode());&#10;        QueryWrapper&lt;UserIdentityDO&gt; wrapper = new QueryWrapper&lt;&gt;();&#10;        wrapper.lambda()&#10;                .eq(UserIdentityDO::getIdentityType, IdentityConstant.ALIPAY_IDENTITY)&#10;                .eq(UserIdentityDO::getIdentifier, alipayUserId);&#10;        UserIdentityDO identity = userIdentityService.getOne(wrapper);&#10;        UserDO user;&#10;        if (identity == null) {&#10;            user = UserDO.builder()&#10;                    .username(&quot;alipay_&quot; + alipayUserId)&#10;                    .nickname(dto.getNickname())&#10;                    .avatar(dto.getAvatar())&#10;                    .build();&#10;            userService.save(user);&#10;            userIdentityService.createIdentity(user.getId(), IdentityConstant.ALIPAY_IDENTITY, alipayUserId, &quot;&quot;);&#10;        } else {&#10;            user = userService.getById(identity.getUserId());&#10;            user.setNickname(dto.getNickname());&#10;            user.setAvatar(dto.getAvatar());&#10;            userService.updateById(user);&#10;        }&#10;&#10;        // 加载用户的身份信息&#10;        QueryWrapper&lt;UserIdentityDO&gt; identityWrapper = new QueryWrapper&lt;&gt;();&#10;        identityWrapper.lambda().eq(UserIdentityDO::getUserId, user.getId());&#10;        user.setIdentities(userIdentityService.list(identityWrapper));&#10;&#10;        Tokens tokens = jwt.generateTokens(user.getId());&#10;        Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();&#10;        data.put(&quot;token&quot;, tokens.getAccessToken());&#10;        data.put(&quot;refreshToken&quot;, tokens.getRefreshToken());&#10;        Map&lt;String, Object&gt; res = new HashMap&lt;&gt;();&#10;        res.put(&quot;code&quot;, 0);&#10;        res.put(&quot;message&quot;, &quot;ok&quot;);&#10;        res.put(&quot;data&quot;, data);&#10;        return res;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/model/UserDO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/io/github/talelin/latticy/model/UserDO.java" />
              <option name="originalContent" value="package io.github.talelin.latticy.model;&#10;&#10;import com.baomidou.mybatisplus.annotation.TableName;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.EqualsAndHashCode;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.io.Serializable;&#10;&#10;/**&#10; * @author pedro@TaleLin&#10; * @author Juzi@TaleLin&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@TableName(&quot;lin_user&quot;)&#10;@EqualsAndHashCode(callSuper = true)&#10;public class UserDO extends BaseModel implements Serializable {&#10;&#10;    private static final long serialVersionUID = -1463999384554707735L;&#10;&#10;    /**&#10;     * 用户名，唯一&#10;     */&#10;    private String username;&#10;&#10;    /**&#10;     * 用户昵称&#10;     */&#10;    private String nickname;&#10;&#10;    /**&#10;     * 头像url&#10;     */&#10;    private String avatar;&#10;&#10;    /**&#10;     * 邮箱&#10;     */&#10;    private String email;&#10;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package io.github.talelin.latticy.model;&#10;&#10;import com.baomidou.mybatisplus.annotation.TableField;&#10;import com.baomidou.mybatisplus.annotation.TableName;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import lombok.EqualsAndHashCode;&#10;import lombok.NoArgsConstructor;&#10;&#10;import java.io.Serializable;&#10;import java.util.List;&#10;&#10;/**&#10; * @author pedro@TaleLin&#10; * @author Juzi@TaleLin&#10; */&#10;@Data&#10;@Builder&#10;@NoArgsConstructor&#10;@AllArgsConstructor&#10;@TableName(&quot;lin_user&quot;)&#10;@EqualsAndHashCode(callSuper = true)&#10;public class UserDO extends BaseModel implements Serializable {&#10;&#10;    private static final long serialVersionUID = -1463999384554707735L;&#10;&#10;    /**&#10;     * 用户名，唯一&#10;     */&#10;    private String username;&#10;&#10;    /**&#10;     * 用户昵称&#10;     */&#10;    private String nickname;&#10;&#10;    /**&#10;     * 头像url&#10;     */&#10;    private String avatar;&#10;&#10;    /**&#10;     * 邮箱&#10;     */&#10;    private String email;&#10;&#10;    /**&#10;     * 用户身份信息列表&#10;     */&#10;    @TableField(exist = false)&#10;    private List&lt;UserIdentityDO&gt; identities;&#10;&#10;    /**&#10;     * 获取支付宝用户ID&#10;     */&#10;    public String getAlipayUserId() {&#10;        if (identities == null) {&#10;            return null;&#10;        }&#10;        return identities.stream()&#10;                .filter(identity -&gt; &quot;ALIPAY&quot;.equals(identity.getIdentityType()))&#10;                .map(UserIdentityDO::getIdentifier)&#10;                .findFirst()&#10;                .orElse(null);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>